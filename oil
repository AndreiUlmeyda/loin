#!/bin/bash

BASEDIR=$(readlink -f "$0" | xargs dirname)

function bookmarksAsJson {
	buku -p -j
}

function jsonToLine {
	"$BASEDIR"/jsonToLine.jq
}

function formatColumns {
	"$BASEDIR"/format-columns.awk
}

function searchAsYouType {
	# enable multiline selection by default, show mode of operation, enable passing strings
	# to peco which are not displayed but used as output
	if [[ "$forceMultilineSelection" == true ]]; then
		peco --rcfile $tmpPecoConfig --null
	else
		peco --prompt "$mode" --null
	fi
}

function searchAndSelectBookmarks {
	bookmarksAsJson |
	jsonToLine |
	formatColumns |
	searchAsYouType
}

function openInBrowser {
	while read -r selectedUrlAndIndex; do
		selectedUrl=${selectedUrlAndIndex%|*}
		xdg-open "$selectedUrl"
	done
}

function openBookmarks {
	searchAndSelectBookmarks | openInBrowser
}

function exitWhenEmpty {
	if [[ -z $1 ]]; then
		exit 0
	fi
}

function askUserForTag {
	read -r -p "input the comma separated list of tags to add: " tag
	echo "$tag"
}

function tagBookmarks {
	urlsAndIndices=(`searchAndSelectBookmarks`)
	exitWhenEmpty $urlsAndIndices
	tag=$(askUserForTag)

	for urlAndIndex in "${urlsAndIndices[@]}"; do
		index="${urlAndIndex#*|}"
		buku --update "$index" --tag "$tag"
	done
}

function updateTitles {
	urlsAndIndices=(`searchAndSelectBookmarks`)
	exitWhenEmpty $urlsAndIndices
	for urlAndIndex in "${urlsAndIndices[@]}"; do
		index="${urlAndIndex#*|}"
		buku -p "$index"
		read -r -p "Enter a new title for the bookmark above: " newTitle
		if [[ -n $newTitle ]]; then
			buku --tacit -u "$index" -t "$newTitle"
		else
			echo "The new title was empty, no update was done."
		fi
	done
}

function deleteBookmarks {
	urlsAndIndices=(`searchAndSelectBookmarks`)
	exitWhenEmpty $urlsAndIndices

	for urlAndIndex in "${urlsAndIndices[@]}"; do
		url="${urlAndIndex%|*}"
		withoutTrailingSlash="${url%/}"
		buku --sany "$withoutTrailingSlash" --delete
	done
}

function parseFlags {
	# check if getopt is available
	parsingLibraryError="The method used to parse command line flags is not available on your system, see the github page for directions."
	getopt --test > /dev/null
	if [[ $? -ne 4 ]]; then
	    echo "$parsingLibraryError"
	    exit 1
	fi

	# specify valid flags
	shortOptions=htTpd
	longOptions=help,tag,title,delete,no-peco-reconfiguration

	parsed=$(getopt --options $shortOptions --longoptions $longOptions --name "$0" -- "$@")

	# exit if parsing arguments failed
	if [[ $? -ne 0 ]]; then
	    exit 1
	fi

	helpText="herpderp"

	while true; do
	    case "$1" in
	    	-h|--help)
				echo "$helpText"
				exit 0
				;;
	        -t|--tag)
	            mode="tag"
	            shift
	            ;;
	        -T|--title)
	            mode="title"
	            shift
	            ;;
	        -d|--delete)
	        	mode="delete"
	        	shift
	        	;;
	        -p|--no-peco-reconfiguration)
	        	forceMultilineSelection=false
	        	shift
	        	;;
	        *)
				break
				;;
	    esac
	done
}

# if not specified otherwise, make a temporary file for use as a custom peco config that has multiline selection enabled
function prepareMultilineSelection {
	if [[ "$forceMultilineSelection" == true ]]; then
		tmpPecoConfig=$(mktemp /tmp/oil-multiline-selection.XXX)
		config="{\"Prompt\":\"$mode\",\"StickySelection\": true,\"Action\":{\"selectAndMoveDown\":[\"peco.ToggleSelection\",\"peco.SelectDown\"]},\"Keymap\":{\"C-Space\":\"selectAndMoveDown\",\"ArrowLeft\":\"peco.ScrollLeft\",\"ArrowRight\":\"peco.ScrollRight\"}}"
		echo $config > $tmpPecoConfig
	fi
}

function runSelectedMode {
	case "$mode" in
	open)
		openBookmarks
		;;
	tag)
		tagBookmarks
		;;
	title)
		updateTitles
		;;
	delete)
		deleteBookmarks
		;;
	esac
}

function cleanUp {
	if [[ -e $tmpPecoConfig ]]; then
		rm $tmpPecoConfig
	fi
}


# default behaviour
mode="open"
forceMultilineSelection=true

# run
parseFlags $@
prepareMultilineSelection
runSelectedMode
cleanUp
